前面 Go 语言的变量和类型那一节提到了数组，数组在 Go 语言中是非常基础的一个东西，虽然后面的切片比数组更常用，但是数组是切片等数据结构的基础，理解了数组对于后面学习切片和 map 等更有帮助。

Go 语言的数组和 Java 的数组类似，都是`长度固定`的数据结构，必须存储一段`相同类型`的元素，而且元素还需要`连续`。

### 声明 && 初始化
声明一个数组和声明一个变量类似，不过需要带上类型和数组的长度

```go
var arr [4]int
// arr = [0, 0, 0, 0]
```

在 [4]int 中，4表示数组的长度，int 表示存储元素的类型。此时数组 arr 还是一个零值数组

```go
arr = [4]int{1, 2, 3, 5}
// arr = [1, 2, 3, 5]
```

数组的声明还可以通过 `:=` 方式
```go
arr1 := [3]int{1, 2, 3}     // arr1 = [1, 2, 3]
arr2 := [5]int{1, 2, 3}     // arr2 = [1, 2, 3, 0, 0] 
arr3 := [...]int{1, 2, 3}   // arr3 = [1, 2, 3]
```

### 数组赋值

要注意的是，数组的长度也是数组类型的一部分，`如果两个数组长度不同，这两个数组也是不同类型的`，如果对不同长度的数组进行赋值编译器会报错。

```go
package main

import "fmt"

func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var b [5]int
    b = a
    a[0] = 0
    fmt.Println(a)
    fmt.Println(b)
}

// [0 2 3 4 5]
// [1 2 3 4 5]
```
从代码中我们看出，数组的拷贝后两个数组的值不会共享（可以理解为深拷贝）


### 数组的遍历
我们上一节最后遍历的是切片，其实完全可以拿来遍历数组

```go
package main

import "fmt"

func main() {
    var s = [5]int{1,2,3,4,5}
	for i := 0; i < len(s); i++ {
		fmt.Println(i, s[i])
	}
	fmt.Println("----------")
	for index, value := range s {
		fmt.Println(index, value)
    }
    // 如果不想要第二个值 可以通过 _ 代替
    // for index, _ := range s {
	// 	fmt.Println(index)
    // }
}
// 打印结果
0 1
1 2
2 3
3 4
4 5
----------
0 1
1 2
2 3
3 4
4 5
```